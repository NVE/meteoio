/***********************************************************************************/
/*  Copyright 2009 WSL Institute for Snow and Avalanche Research    SLF-DAVOS      */
/***********************************************************************************/
/* This file is part of MeteoIO.
    MeteoIO is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    MeteoIO is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with MeteoIO.  If not, see <http://www.gnu.org/licenses/>.
*/
#include "CosmoXMLIO.h"
#include <Atmosphere.h>

using namespace std;

namespace mio {
/**
 * @page cosmoxml COSMOXML
 * @section cosmoxml_format Format
 * This plugin reads the XML files as generated by the Cosmo system.
 * The files are outputted in Grib format and preprocessed by FieldExtra (MeteoSwiss)
 * to get XML files.
 * It requires libxml to compile and run.
 *
 * @section cosmoxml_units Units
 * The units are assumed to be the following:
 * - temperatures in celsius
 * - relative humidity in %
 * - wind speed in m/s
 * - precipitations in mm/h
 * - radiation in W/mÂ²
 *
 * @section cosmoxml_keywords Keywords
 * This plugin uses the following keywords:
 * - COORDSYS: input coordinate system (see Coords) specified in the [Input] section
 * - COORDPARAM: extra input coordinates parameters (see Coords) specified in the [Input] section
 * - COORDSYS: output coordinate system (see Coords) specified in the [Output] section
 * - COORDPARAM: extra output coordinates parameters (see Coords) specified in the [Output] section
 * - XMLPATH: string containing the path to the xml files
 * - NROFSTATIONS: total number of stations listed for use
 * - STATION#: station id for the given number #
 */

const double CosmoXMLIO::plugin_nodata = -999.; //plugin specific nodata value. It can also be read by the plugin (depending on what is appropriate)

struct indent {
  int depth_;
  indent(int depth): depth_(depth) {};
};

std::ostream & operator<<(std::ostream & o, indent const & in)
{
  for(int i = 0; i != in.depth_; ++i)
  {
    o << "  ";
  }
  return o;
}


CosmoXMLIO::CosmoXMLIO(void (*delObj)(void*), const Config& i_cfg) : IOInterface(delObj), cfg(i_cfg)
{
	IOUtils::getProjectionParameters(cfg, coordin, coordinparam, coordout, coordoutparam);
}

CosmoXMLIO::CosmoXMLIO(const std::string& configfile) : IOInterface(NULL), cfg(configfile)
{
	IOUtils::getProjectionParameters(cfg, coordin, coordinparam, coordout, coordoutparam);
}

CosmoXMLIO::CosmoXMLIO(const Config& cfgreader) : IOInterface(NULL), cfg(cfgreader)
{
	IOUtils::getProjectionParameters(cfg, coordin, coordinparam, coordout, coordoutparam);
}

CosmoXMLIO::~CosmoXMLIO() throw()
{
	
}

void CosmoXMLIO::read2DGrid(Grid2DObject& /*grid_out*/, const std::string& /*_name*/)
{
	//Nothing so far
	throw IOException("Nothing implemented here", AT);
}

void CosmoXMLIO::readDEM(DEMObject& /*dem_out*/)
{
	//Nothing so far
	throw IOException("Nothing implemented here", AT);
}

void CosmoXMLIO::readLanduse(Grid2DObject& /*landuse_out*/)
{
	//Nothing so far
	throw IOException("Nothing implemented here", AT);
}

void CosmoXMLIO::readAssimilationData(const Date& /*date_in*/, Grid2DObject& /*da_out*/)
{
	//Nothing so far
	throw IOException("Nothing implemented here", AT);
}

void CosmoXMLIO::readStationData(const Date&, std::vector<StationData>& /*vecStation*/)
{
	//Nothing so far
	// -----> Implemented in readMeteoData <-----
	throw IOException("Nothing implemented here", AT);
}

//-----> Functions used to read XML files <-----
std::string CosmoXMLIO::getValue(xmlpp::TextReader& reader) {
	reader.move_to_element();
	reader.read();
	const string value = reader.get_value();
	reader.read();
	reader.read();
	return( value );
}

double CosmoXMLIO::getDoubleValue(xmlpp::TextReader& reader) {
	double value;
	const string Svalue = getValue(reader);
	if( IOUtils::convertString(value, Svalue) == false) {
		stringstream ss;
		ss << "Can not parse (double)" << Svalue;
		throw ConversionFailedException(ss.str(), AT);
	}
	return value;
}

Date CosmoXMLIO::getDateValue(xmlpp::TextReader& reader) {
	Date date;
	const string Svalue = getValue(reader);
	if( IOUtils::convertString(date, Svalue) == false) {
		stringstream ss;
		ss << "Can not parse (date)" << Svalue;
		throw ConversionFailedException(ss.str(), AT);
	}
	return date;
}

void CosmoXMLIO::readStationNames(std::vector<std::string>& vecStationName)
{
	vecStationName.clear();

	//Read in the StationNames
	string xmlpath="", str_stations="";
	unsigned int stations=0;

	cfg.getValue("NROFSTATIONS", "Input", str_stations);

	if (str_stations == "")
		throw ConversionFailedException("Error while reading value for NROFSTATIONS", AT);

	if (!IOUtils::convertString(stations, str_stations, std::dec))
		throw ConversionFailedException("Error while reading value for NROFSTATIONS", AT);

	for (unsigned int ii=0; ii<stations; ii++) {
		stringstream tmp_stream;
		string stationname="", tmp_file="";

		tmp_stream << (ii+1); //needed to construct key name
		cfg.getValue(string("STATION"+tmp_stream.str()), "Input", stationname);
		std::cout << "\tRead io.ini stationname: '" << stationname << "'" << std::endl;
		vecStationName.push_back(stationname);
	}
}

//-----> Read meteo and station data <-----
void CosmoXMLIO::readMeteoData(const Date& /*dateStart*/, const Date& /*dateEnd*/,
					    std::vector< std::vector<MeteoData> >& vecMeteo, 
					    const unsigned int&)
{
	vector<string> vecStationName;
	readStationNames(vecStationName);
	vecMeteo.clear();

	string meteopath="", station_path="";

	cfg.getValue("METEOPATH", "Input", meteopath);

	if (meteopath == "")
		throw ConversionFailedException("Error while reading value for METEOPATH", AT);


	vecMeteo.insert(vecMeteo.begin(), vecStationName.size(), std::vector<MeteoData>()); //allocation for the vectors

	for (unsigned int ii=0; ii<vecStationName.size(); ii++) {	
		station_path = meteopath + "/" + vecStationName[ii] + ".xml";
		cout << station_path << endl;
		
		MeteoData meteo;
		StationData station;
		//Initialize variables
		double altitude=IOUtils::nodata, latitude=IOUtils::nodata, longitude=IOUtils::nodata;
		double nodata=IOUtils::nodata;
		double temperature=IOUtils::nodata, dew_point=IOUtils::nodata, global_radiation=IOUtils::nodata;
		double rain=IOUtils::nodata, wind_speed=IOUtils::nodata, max_wind_speed=IOUtils::nodata;
		Date olddate=IOUtils::nodata, newdate=IOUtils::nodata;
		int write=0;
		
		//Read station and meteo data
		//xmlpp::TextReader reader("./input/meteo/GribMD2.xml");
		xmlpp::TextReader reader(station_path);
		while(reader.read()) {
			if(reader.has_attributes()) {
				reader.move_to_first_attribute();
				const string key=reader.get_value();
				//StationData
				if(key=="identifier") station.stationName = getValue(reader);
				if(key=="station_abbreviation") station.stationID = getValue(reader);
				if(key=="station.height") altitude = getDoubleValue(reader);
				if(key=="station.latitude") latitude = getDoubleValue(reader);
				if(key=="station.longitude") longitude = getDoubleValue(reader);
	// 			if(key=="model_station_height") altitude = getDoubleValue(reader);
	// 			if(key=="model_station_latitude") latitude = getDoubleValue(reader);
	// 			if(key=="model_station_longitude") longitude = getDoubleValue(reader);
				if(key=="missing_value_code") nodata = getDoubleValue(reader);
				//MeteoData
				if(key=="T_2M") temperature = getDoubleValue(reader);
				if(key=="TD_2M") dew_point = getDoubleValue(reader);
				if(key=="GLOB") global_radiation = getDoubleValue(reader);
				if(key=="TOT_PREC") rain = getDoubleValue(reader);
				if(key=="FF_10M") wind_speed = getDoubleValue(reader);
				if(key=="VMAX_10M") max_wind_speed = getDoubleValue(reader);
				//WriteData
				if(key=="reference_ts") {
					if(write==0) {
						write=1;	//Doesn't print first data set
						olddate = getDateValue(reader);
					}
					else {
						newdate = getDateValue(reader);
						meteo.date = olddate;
						olddate = newdate;
						if(altitude!=IOUtils::nodata && latitude!=IOUtils::nodata && longitude!=IOUtils::nodata) {
							station.position.setLatLon(latitude, longitude, altitude);
						} else {
							throw InvalidFormatException("Meteo data found, but no position information", AT);
						}
						meteo.meta = station;
						meteo.ta=temperature;
						//meteo.rh=humidity;		
						meteo.rh=DewPointtoRh(humidity,temperature,TRUE)	//Create humidity from the dew point
						meteo.iswr=global_radiation;
						meteo.hnw=rain;
						meteo.vw=wind_speed;
						//meteo.mvw=max_wind_speed;	//HACK create variable
						//cout << meteo; //To check if the data set is well written
						vecMeteo[ii].push_back( meteo ); //HACK set index
					}
				}
			}
		}
		//Print the last set of data
		meteo.date = olddate;
		if(altitude!=IOUtils::nodata && latitude!=IOUtils::nodata && longitude!=IOUtils::nodata) {
			station.position.setLatLon(latitude, longitude, altitude);
		} else {
			throw InvalidFormatException("Meteo data found, but no position information", AT);
		}
		meteo.meta = station;
		meteo.ta=temperature;
		meteo.rh=DewPointtoRh(humidity,temperature,TRUE)	//Create humidity from the dew point
		meteo.iswr=global_radiation;
		meteo.hnw=rain;
		meteo.vw=wind_speed;
		//meteo.mvw=max_wind_speed;	//HACK create variable
		//cout << meteo; //To check if the data set is well written
		vecMeteo[ii].push_back( meteo ); //HACK set index
		reader.close();
	}
		
	
/*	catch(const std::exception& e)
	{
		std::cout << "Exception caught: " << e.what() << std::endl;
	}*/
	
	std::cout<<"Meteo Data read!"<<std::endl;
	//throw IOException("Nothing implemented here", AT); //Has to be removed once programm is written!!!
}

void CosmoXMLIO::writeMeteoData(const std::vector< std::vector<MeteoData> >& /*vecMeteo*/,
						const std::string&)
{
	//Nothing so far
	throw IOException("Nothing implemented here", AT);
}

void CosmoXMLIO::readSpecialPoints(std::vector<Coords>&)
{
	//Nothing so far
	throw IOException("Nothing implemented here", AT);
}

void CosmoXMLIO::write2DGrid(const Grid2DObject& /*grid_in*/, const std::string& /*name*/)
{
	//Nothing so far
	throw IOException("Nothing implemented here", AT);
}

void CosmoXMLIO::cleanup() throw()
{
	
}

#ifndef _METEOIO_JNI
extern "C"
{
	void deleteObject(void* obj) {
		delete reinterpret_cast<PluginObject*>(obj);
	}

	void* loadObject(const string& classname, const Config& cfg) {
		if(classname == "CosmoXMLIO") {
			//cerr << "Creating dynamic handle for " << classname << endl;
			return new CosmoXMLIO(deleteObject, cfg);
		}
		//cerr << "Could not load " << classname << endl;
		return NULL;
	}
}
#endif



} //namespace
