/***********************************************************************************/
/*  Copyright 2009 WSL Institute for Snow and Avalanche Research    SLF-DAVOS      */
/***********************************************************************************/
/* This file is part of MeteoIO.
    MeteoIO is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    MeteoIO is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with MeteoIO.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <meteoio/plugins/CosmoXMLIO.h>
#include <meteoio/meteolaws/Atmosphere.h>
#include <sstream>

// reading a text file
#include <iostream>
#include <fstream>
#include <string>

using namespace std;

namespace mio {
/**
 * @page cosmoxml COSMOXML
 * @section cosmoxml_format Format
 * This plugin reads the XML files as generated by the Cosmo system.
 * The files are outputted in Grib format and preprocessed by FieldExtra (MeteoSwiss)
 * to get XML files.
 * It requires libxml to compile and run.
 *
 * @section cosmoxml_units Units
 * The units are assumed to be the following:
 * - temperatures in celsius
 * - relative humidity in %
 * - wind speed in m/s
 * - precipitations in mm/h
 * - radiation in W/m²
 *
 * @section cosmoxml_keywords Keywords
 * This plugin uses the following keywords:
 * - COORDSYS: input coordinate system (see Coords) specified in the [Input] section
 * - COORDPARAM: extra input coordinates parameters (see Coords) specified in the [Input] section
 * - COORDSYS: output coordinate system (see Coords) specified in the [Output] section
 * - COORDPARAM: extra output coordinates parameters (see Coords) specified in the [Output] section
 * - XMLPATH: string containing the path to the xml files
 * - NROFSTATIONS: total number of stations listed for use
 * - STATION#: station id for the given number #
 */

const double CosmoXMLIO::plugin_nodata = -999.; //plugin specific nodata value. It can also be read by the plugin (depending on what is appropriate)
const double CosmoXMLIO::in_tz = 0.; //plugin specific timezone
const double CosmoXMLIO::out_tz = 0.; //plugin specific time zone

struct indent {
  int depth_;
  indent(int depth): depth_(depth) {};
};

std::ostream & operator<<(std::ostream & o, indent const & in)
{
  for(int i = 0; i != in.depth_; ++i)
  {
    o << "  ";
  }
  return o;
}


CosmoXMLIO::CosmoXMLIO(void (*delObj)(void*), const Config& i_cfg) : IOInterface(delObj), cfg(i_cfg)
{
	IOUtils::getProjectionParameters(cfg, coordin, coordinparam, coordout, coordoutparam);
}

CosmoXMLIO::CosmoXMLIO(const std::string& configfile) : IOInterface(NULL), cfg(configfile)
{
	IOUtils::getProjectionParameters(cfg, coordin, coordinparam, coordout, coordoutparam);
}

CosmoXMLIO::CosmoXMLIO(const Config& cfgreader) : IOInterface(NULL), cfg(cfgreader)
{
	IOUtils::getProjectionParameters(cfg, coordin, coordinparam, coordout, coordoutparam);
}

CosmoXMLIO::~CosmoXMLIO() throw()
{
	
}

void CosmoXMLIO::read2DGrid(Grid2DObject& /*grid_out*/, const std::string& /*_name*/)
{
	//Nothing so far
	throw IOException("Nothing implemented here", AT);
}

void CosmoXMLIO::readDEM(DEMObject& /*dem_out*/)
{
	//Nothing so far
	throw IOException("Nothing implemented here", AT);
}

void CosmoXMLIO::readLanduse(Grid2DObject& /*landuse_out*/)
{
	//Nothing so far
	throw IOException("Nothing implemented here", AT);
}

void CosmoXMLIO::readAssimilationData(const Date& /*date_in*/, Grid2DObject& /*da_out*/)
{
	//Nothing so far
	throw IOException("Nothing implemented here", AT);
}

void CosmoXMLIO::readStationData(const Date&, std::vector<StationData>& /*vecStation*/)
{
	//Nothing so far
	// -----> Implemented in readMeteoData <-----
	throw IOException("Nothing implemented here", AT);
}

//-----> Functions used to read XML files <-----
std::string CosmoXMLIO::getValue(xmlpp::TextReader& reader) {
	reader.move_to_element();
	reader.read();
	const string value = reader.get_value();
	reader.read();
	reader.read();
	return( value );
}

double CosmoXMLIO::getDoubleValue(xmlpp::TextReader& reader) {
	double value;
	const string Svalue = getValue(reader);
	if( IOUtils::convertString(value, Svalue) == false) {
		stringstream ss;
		ss << "Can not parse (double)" << Svalue;
		throw ConversionFailedException(ss.str(), AT);
	}
	return value;
}

Date CosmoXMLIO::getDateValue(xmlpp::TextReader& reader) {
	Date date;
	const string Svalue = getValue(reader);
	if( IOUtils::convertString(date, Svalue, in_tz) == false) {
		stringstream ss;
		ss << "Can not parse (date)" << Svalue;
		throw ConversionFailedException(ss.str(), AT);
	}
	return date;
}

void CosmoXMLIO::readStationNames(std::vector<std::string>& vecStationName)
{
	vecStationName.clear();

	//Read in the StationNames
	string xmlpath="", str_stations="";
	unsigned int stations=0;

	cfg.getValue("NROFSTATIONS", "Input", str_stations);

	if (str_stations == "")
		throw ConversionFailedException("Error while reading value for NROFSTATIONS", AT);

	if (!IOUtils::convertString(stations, str_stations, std::dec))
		throw ConversionFailedException("Error while reading value for NROFSTATIONS", AT);

	for (unsigned int ii=0; ii<stations; ii++) {
		stringstream tmp_stream;
		string stationname="", tmp_file="";

		tmp_stream << (ii+1); //needed to construct key name
		cfg.getValue(string("STATION"+tmp_stream.str()), "Input", stationname);
		std::cout << "\tRead io.ini stationname: '" << stationname << "'" << std::endl;
		vecStationName.push_back(stationname);
	}
	
	//-----> Version for a directory with station list <-----//
	
	//Get all files from directory
	string meteopath = "";
 	cfg.getValue("METEOPATH", "Input", meteopath);
	if (meteopath == "")
		throw ConversionFailedException("Error while reading value for METEOPATH", AT);	
	const string pattern = "xml";
	list<string> dirlist;
	IOUtils::readDirectory(meteopath, dirlist, pattern);
	dirlist.sort();
	//Plot all the station names
	list<string>::iterator itr;
	for( itr = dirlist.begin(); itr != dirlist.end(); itr++ ) {
		cout<<meteopath<<"/"<<*itr<<endl; //itr does not contain the path
	}
}



//-----> Read meteo and station data <----- SECOND VERSION: uses stations directory
void CosmoXMLIO::readMeteoData(const Date& /*dateStart*/, const Date& /*dateEnd*/,
					    std::vector< std::vector<MeteoData> >& vecMeteo, 
					    const unsigned int&)
{
	//Get all files from directory
	string meteopath = "", station_path="";
 	cfg.getValue("METEOPATH", "Input", meteopath);
	if (meteopath == "")
		throw ConversionFailedException("Error while reading value for METEOPATH", AT);	
	const string pattern = "xml";
	list<string> dirlist;
	IOUtils::readDirectory(meteopath, dirlist, pattern);
	dirlist.sort();
	
	vecMeteo.clear();	//Initialize Meteo Vector

	vecMeteo.insert(vecMeteo.begin(), dirlist.size(), std::vector<MeteoData>()); //Allocation for the vectors
	list<string>::iterator itr;	//To loop in the stations list
	
	//Plot all the station names
	cout << endl << "Files available:" << endl;
	for( itr = dirlist.begin(); itr != dirlist.end(); itr++ ) {
		cout<<meteopath<<"/"<<*itr<<endl; //itr does not contain the path -> create the name.
	}
	cout << endl;
	
	unsigned int ii=0; //Declare and initialize counter (to know which station we are dealing with)
	for( itr = dirlist.begin(); itr != dirlist.end(); itr++ ) {	
		station_path = meteopath + "/" + *itr;
		cout << "Reading file " << station_path << endl;
		
		MeteoData meteo;
		StationData station;
		//Initialize variables
		double altitude=IOUtils::nodata, latitude=IOUtils::nodata, longitude=IOUtils::nodata;
		double nodata=IOUtils::nodata;
		double temperature=IOUtils::nodata, dew_point=IOUtils::nodata, global_radiation=IOUtils::nodata;
		double rain=IOUtils::nodata, wind_speed=IOUtils::nodata, max_wind_speed=IOUtils::nodata;
		Date olddate, newdate;
		int write=0;
		
		//Read station and meteo data
		//xmlpp::TextReader reader("./input/meteo/GribMD2.xml");
		xmlpp::TextReader reader(station_path);
		while(reader.read()) {
			if(reader.has_attributes()) {
				reader.move_to_first_attribute();
				const string key=reader.get_value();
				//StationData
				if(key=="identifier") station.stationName = getValue(reader);
				if(key=="station_abbreviation") station.stationID = getValue(reader);
				if(key=="station.height") altitude = getDoubleValue(reader);
				if(key=="station.latitude") latitude = getDoubleValue(reader);
				if(key=="station.longitude") longitude = getDoubleValue(reader);
	// 			if(key=="model_station_height") altitude = getDoubleValue(reader);
	// 			if(key=="model_station_latitude") latitude = getDoubleValue(reader);
	// 			if(key=="model_station_longitude") longitude = getDoubleValue(reader);
				if(key=="missing_value_code") nodata = getDoubleValue(reader);
				//MeteoData
				if(key=="T_2M") temperature = getDoubleValue(reader);
				if(key=="TD_2M") dew_point = getDoubleValue(reader);
				if(key=="GLOB") global_radiation = getDoubleValue(reader);
				if(key=="TOT_PREC") rain = getDoubleValue(reader);
				if(key=="FF_10M") wind_speed = getDoubleValue(reader);
				if(key=="VMAX_10M") max_wind_speed = getDoubleValue(reader);
				//WriteData
				if(key=="reference_ts") {
					if(write==0) {
						write=1;	//Doesn't print first data set, as it is only definition
						//HACK may want to check what we have in the values and print them if numbers and not definitions...
						olddate = getDateValue(reader);
					}
					else {
						newdate = getDateValue(reader);
						meteo.date = olddate;
						olddate = newdate;
						if(altitude!=IOUtils::nodata && latitude!=IOUtils::nodata && longitude!=IOUtils::nodata) {
							station.position.setLatLon(latitude, longitude, altitude);
						} else {
							throw InvalidFormatException("Meteo data found, but no position information", AT);
						}
						meteo.meta = station;
						meteo.ta=C_TO_K(temperature);
						meteo.rh=Atmosphere::DewPointtoRh(C_TO_K(dew_point),C_TO_K(temperature),TRUE);	//Create humidity from the dew point, uses °K and not °C
						meteo.iswr=global_radiation;
						meteo.hnw=rain;
						meteo.vw=wind_speed;
						//meteo.mvw=max_wind_speed;	//HACK create variable
						//cout << meteo; //To check if the data set is well written
						vecMeteo[ii].push_back( meteo ); //HACK set index
						//Initialize MeteoData
						temperature=IOUtils::nodata, dew_point=IOUtils::nodata, global_radiation=IOUtils::nodata;
						rain=IOUtils::nodata, wind_speed=IOUtils::nodata, max_wind_speed=IOUtils::nodata;
					}
				}
			}
		}
		//Save the last set of data
		meteo.date = olddate;
		if(altitude!=IOUtils::nodata && latitude!=IOUtils::nodata && longitude!=IOUtils::nodata) {
			station.position.setLatLon(latitude, longitude, altitude);
		} else {
			throw InvalidFormatException("Meteo data found, but no position information", AT);
		}
		meteo.meta = station;
		meteo.ta=C_TO_K(temperature);
		meteo.rh=Atmosphere::DewPointtoRh(C_TO_K(dew_point),C_TO_K(temperature),TRUE);	//Create humidity from the dew point, uses °K and not °C
		meteo.iswr=global_radiation;
		meteo.hnw=rain;
		meteo.vw=wind_speed;
		//meteo.mvw=max_wind_speed;	//HACK create variable
		cout << meteo; //To check if the data set is well written
		//cout << "No data code= "<<nodata<<endl;
		vecMeteo[ii].push_back( meteo ); //HACK set index
		reader.close();
		//Increment counter
		ii++;
	}
	cout << endl << "Meteo Data read" << endl << endl;
	
	//TEST Write meteo data
	writeMeteoData(vecMeteo);
}
//-----> End of Read meteo and Station data <-----

// //-----> Read meteo and station data <----- FIRST VERSION: uses stations list
// void CosmoXMLIO::readMeteoData(const Date& /*dateStart*/, const Date& /*dateEnd*/,
// 					    std::vector< std::vector<MeteoData> >& vecMeteo, 
// 					    const unsigned int&)
// {
// 	vector<string> vecStationName;
// 	readStationNames(vecStationName);
// 	vecMeteo.clear();
// 
// 	string meteopath="", station_path="";
// 	int timezone_in;
// 
// 	cfg.getValue("METEOPATH", "Input", meteopath);
// 
// 	if (meteopath == "")
// 		throw ConversionFailedException("Error while reading value for METEOPATH", AT);
// 
// 	cfg.getValue("TZ", "Input", timezone_in);
// 
// 	vecMeteo.insert(vecMeteo.begin(), vecStationName.size(), std::vector<MeteoData>()); //allocation for the vectors
// 
// 	for (unsigned int ii=0; ii<vecStationName.size(); ii++) {	
// 		station_path = meteopath + "/" + vecStationName[ii] + ".xml";
// 		// cout << station_path << endl;
// 		
// 		MeteoData meteo;
// 		StationData station;
// 		//Initialize variables
// 		double altitude=IOUtils::nodata, latitude=IOUtils::nodata, longitude=IOUtils::nodata;
// 		double nodata=IOUtils::nodata;
// 		double temperature=IOUtils::nodata, dew_point=IOUtils::nodata, global_radiation=IOUtils::nodata;
// 		double rain=IOUtils::nodata, wind_speed=IOUtils::nodata, max_wind_speed=IOUtils::nodata;
// 		Date olddate=IOUtils::nodata, newdate=IOUtils::nodata;
// 		int write=0;
// 		
// 		//Read station and meteo data
// 		//xmlpp::TextReader reader("./input/meteo/GribMD2.xml");
// 		xmlpp::TextReader reader(station_path);
// 		while(reader.read()) {
// 			if(reader.has_attributes()) {
// 				reader.move_to_first_attribute();
// 				const string key=reader.get_value();
// 				//StationData
// 				if(key=="identifier") station.stationName = getValue(reader);
// 				if(key=="station_abbreviation") station.stationID = getValue(reader);
// 				if(key=="station.height") altitude = getDoubleValue(reader);
// 				if(key=="station.latitude") latitude = getDoubleValue(reader);
// 				if(key=="station.longitude") longitude = getDoubleValue(reader);
// 	// 			if(key=="model_station_height") altitude = getDoubleValue(reader);
// 	// 			if(key=="model_station_latitude") latitude = getDoubleValue(reader);
// 	// 			if(key=="model_station_longitude") longitude = getDoubleValue(reader);
// 				if(key=="missing_value_code") nodata = getDoubleValue(reader);
// 				//MeteoData
// 				if(key=="T_2M") temperature = getDoubleValue(reader);
// 				if(key=="TD_2M") dew_point = getDoubleValue(reader);
// 				if(key=="GLOB") global_radiation = getDoubleValue(reader);
// 				if(key=="TOT_PREC") rain = getDoubleValue(reader);
// 				if(key=="FF_10M") wind_speed = getDoubleValue(reader);
// 				if(key=="VMAX_10M") max_wind_speed = getDoubleValue(reader);
// 				//WriteData
// 				if(key=="reference_ts") {
// 					if(write==0) {
// 						write=1;	//Doesn't print first data set
// 						olddate = getDateValue(reader);
// 					}
// 					else {
// 						newdate = getDateValue(reader);
// 						meteo.date = olddate;
// 						olddate = newdate;
// 						if(altitude!=IOUtils::nodata && latitude!=IOUtils::nodata && longitude!=IOUtils::nodata) {
// 							station.position.setLatLon(latitude, longitude, altitude);
// 						} else {
// 							throw InvalidFormatException("Meteo data found, but no position information", AT);
// 						}
// 						if (timezone_in != 0.0) meteo.date.setTimeZone(timezone_in);
// 						//cout<<"Timezone in= "<<timezone_in<<endl;
// 						meteo.meta = station;
// 						meteo.ta=temperature;
// 						meteo.rh=Atmosphere::DewPointtoRh(C_TO_K(dew_point),C_TO_K(temperature),TRUE);	//Create humidity from the dew point, uses °K and not °C
// 						meteo.iswr=global_radiation;
// 						meteo.hnw=rain;
// 						meteo.vw=wind_speed;
// 						//meteo.mvw=max_wind_speed;	//HACK create variable
// 						//cout << meteo; //To check if the data set is well written
// 						vecMeteo[ii].push_back( meteo ); //HACK set index
// 						//Initialize MeteoData
// 						temperature=IOUtils::nodata, dew_point=IOUtils::nodata, global_radiation=IOUtils::nodata;
// 						rain=IOUtils::nodata, wind_speed=IOUtils::nodata, max_wind_speed=IOUtils::nodata;
// 					}
// 				}
// 			}
// 		}
// 		//Print the last set of data
// 		meteo.date = olddate;
// 		if(altitude!=IOUtils::nodata && latitude!=IOUtils::nodata && longitude!=IOUtils::nodata) {
// 			station.position.setLatLon(latitude, longitude, altitude);
// 		} else {
// 			throw InvalidFormatException("Meteo data found, but no position information", AT);
// 		}
// 		if (timezone_in != 0.0) meteo.date.setTimeZone(timezone_in);
// 		meteo.meta = station;
// 		meteo.ta=temperature;
// 		meteo.rh=Atmosphere::DewPointtoRh(C_TO_K(dew_point),C_TO_K(temperature),TRUE);	//Create humidity from the dew point, uses °K and not °C
// 		meteo.iswr=global_radiation;
// 		meteo.hnw=rain;
// 		meteo.vw=wind_speed;
// 		//meteo.mvw=max_wind_speed;	//HACK create variable
// 		//cout << meteo; //To check if the data set is well written
// 		//cout << "No data code= "<<nodata<<endl;
// 		vecMeteo[ii].push_back( meteo ); //HACK set index
// 		reader.close();
// 	}
// 		
// 	
// /*	catch(const std::exception& e)
// 	{
// 		std::cout << "Exception caught: " << e.what() << std::endl;
// 	}*/
// 	
// 	//std::cout<<"Meteo Data read!"<<std::endl;
// 	//throw IOException("Nothing implemented here", AT); //Has to be removed once programm is written!!!
// }

void CosmoXMLIO::writeMeteoData(const std::vector< std::vector<MeteoData> >& vecMeteo,
						const std::string&)
{
	//ofstream XMLfile, fout;
	ofstream fout;
	string filename="", s="", meteopath_out = "", line;
	stringstream XMLdata, out;
	//cfg.getValue("METEOPATH", "Output", meteopath_out);
	meteopath_out = "./meteoOUT/";
	cout << "In writeMeteoData" << endl << endl;
	for (unsigned int ii=0; ii < vecMeteo.size(); ii++) {
		//Read and save in XMLdata first part of XML file (until station data)
		XMLdata.str("");
 		filename = meteopath_out + "/RawXMLfile_part1.xml";
  		ifstream XMLfile_1 (filename.c_str());
  		if (XMLfile_1.is_open()) {
    			while ( XMLfile_1.good() ) {
      				getline (XMLfile_1,line);
				XMLdata << line << endl;
    			}
    			XMLfile_1.close();
  		}
  		else cout << "Unable to open RawXMLfile_part1"; 
		
		//Insert station data
		const StationData& station = vecMeteo[ii][0].meta; //TODO: check that elem 0 exists
		XMLdata << "</col>" << endl << "<col>" << endl << "<ttable id=\"data\">" << endl << "<row>" << endl;
		XMLdata << "<col id=\"identifier\">" << station.getStationName() << "</col>" << endl;
		XMLdata << "<col id=\"station_abbreviation\">" << station.getStationID() << "</col>" << endl;
		XMLdata << "<col id=\"station.height\">" << station.position.getAltitude() << "</col>" << endl;
		XMLdata << "<col id=\"station.latitude\">" << station.position.getLat() << "</col>" << endl;
		XMLdata << "<col id=\"station.longitude\">" << station.position.getLon() << "</col>" << endl;
// 		XMLdata << "<col id=\"model_station_height\">" << "TO DO!" << "</col>" << endl;	//HACK which values do we use? Model or real
// 		XMLdata << "<col id=\"model_station_latitude\">" << "TO DO!" << "</col>" << endl;
// 		XMLdata << "<col id=\"model_station_longitude\">" << "TO DO!" << "</col>" << endl;
// 		XMLdata << "<col id=\"data_cat_number\">" << "TO DO!" << "</col>" << endl;	//HACK do we need these values?
// 		XMLdata << "<col id=\"data_cat_description\">" << "TO DO!" << "</col>" << endl;
// 		XMLdata << "<col id=\"model_configuration\">" << "TO DO!" << "</col>" << endl;
// 		XMLdata << "<col id=\"missing_value_code\">" << nodata << "</col>" << endl;
// 		XMLdata << "<col id=\"model_run_dt\">" << "TO DO!" << "</col>" << endl;

		//Read and save in XMLdata second part of XML file (between station data and meteo data)
 		filename = meteopath_out + "/RawXMLfile_part2.xml";
  		ifstream XMLfile_2 (filename.c_str());
  		if (XMLfile_2.is_open()) {
    			while ( XMLfile_2.good() ) {
      				getline (XMLfile_2,line);
				XMLdata << line << endl;
    			}
    			XMLfile_2.close();
  		}
  		else cout << "Unable to open RawXMLfile_part2"; 

		//Insert meteo data
		XMLdata << "</col>" << endl << "<col>" << endl << "<ttable id=\"data\">" << endl;
		for(unsigned int jj=0; jj<vecMeteo[ii].size(); jj++) {
			XMLdata << "<row>" << endl;
			XMLdata << "<col id=\"identifier\">" << station.getStationName() << "</col>" << endl;
			Date tmp_date(vecMeteo[ii][jj].date);
			tmp_date.setTimeZone(out_tz);
			XMLdata << "<col id=\"reference_ts\">" << tmp_date.toString(Date::NUM) << "</col>" << endl;
			const double ta = vecMeteo[ii][jj].ta;
			XMLdata << "<col id=\"T_2M\">" << K_TO_C(ta) << "</col>" << endl;
	 		const double dew_point=Atmosphere::RhtoDewPoint(vecMeteo[ii][jj].rh,ta,TRUE);
	 		XMLdata << "<col id=\"TD_2M\">" << K_TO_C(dew_point) << "</col>" << endl;
	 		XMLdata << "<col id=\"GLOB\">" << vecMeteo[ii][jj].iswr << "</col>" << endl;
	 		XMLdata << "<col id=\"TOT_PREC\">" << vecMeteo[ii][jj].hnw << "</col>" << endl;
	 		XMLdata << "<col id=\"FF_10M\">" << vecMeteo[ii][jj].vw << "</col>" << endl;
			//XMLdata << "<col id=\"VMAX_10M\">" << vecMeteo[ii].mvw() << "</col>" << endl;		//HACK create variable
			XMLdata << "</row>" << endl;
		}

		//Read and save in XMLdata last part of XML file (after meteo data, only a few lines)
 		filename = meteopath_out + "/RawXMLfile_part3.xml";
  		ifstream XMLfile_3 (filename.c_str());
  		if (XMLfile_3.is_open()) {
    			while ( XMLfile_3.good() ) {
      				getline (XMLfile_3,line);
				XMLdata << line << endl;
    			}
    			XMLfile_3.close();
  		}
  		else cout << "Unable to open RawXMLfile_part3"; 

		//Save file
		//HACK change to get the station name!!!
		//out << ii;
		//s = out.str();
		//filename = meteopath_out + "Station" + station.getStationID() + ".xml";
		filename = meteopath_out + "Station_" + station.getStationID() + ".xml";
		cout << "Filename = " << filename << endl;
		out.str("");
		fout.open(filename.c_str());
		fout << XMLdata.str();
		fout.close();
	}
	cout << endl << "Out of writeMeteoData" << endl << endl;
	//Nothing so far
	//throw IOException("Nothing implemented here", AT);
}

void CosmoXMLIO::readSpecialPoints(std::vector<Coords>&)
{
	//Nothing so far
	throw IOException("Nothing implemented here", AT);
}

void CosmoXMLIO::write2DGrid(const Grid2DObject& /*grid_in*/, const std::string& /*name*/)
{
	//Nothing so far
	throw IOException("Nothing implemented here", AT);
}

void CosmoXMLIO::cleanup() throw()
{
	
}

#ifndef _METEOIO_JNI
extern "C"
{
	void deleteObject(void* obj) {
		delete reinterpret_cast<PluginObject*>(obj);
	}

	void* loadObject(const string& classname, const Config& cfg) {
		if(classname == "CosmoXMLIO") {
			//cerr << "Creating dynamic handle for " << classname << endl;
			return new CosmoXMLIO(deleteObject, cfg);
		}
		//cerr << "Could not load " << classname << endl;
		return NULL;
	}
}
#endif



} //namespace
